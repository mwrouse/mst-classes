# Symbol Tables 
A symbol table is generated by a parser while generating the parse tree, it **maps names to attributes**

Variables, functions, constants, custom types, and more are all mapped in the symbol table. 

### Example 
Given the following code:   
```cpp 
int x; 
const float PI = 3.14;
int a[5];
int foo (int x, float& y);
struct point { int x, y; }
```
The following symbol table would be generated:   
| Name  | Attribute |
|:-----:|:----------|
|x|int|
|PI|const, float, 3.14|
|a|int, 5|
|foo|2, int float&|
|point|2, int x, int y|


## Type Checking 
Type checking can be done by using the symbol table.

*Type Checking* is making sure *operands to operators are compatible*

### Implicit Conversion 
Implicit Conversion is a method used to ensure compatible types for operators 

**Example:** `x = 3 + 'A'` either 3 would be convert to a `char` or `'A'` would be converted to an `int`

### Type Equivalency 
Common methods for checking type equivalency are:     
*Structural* - same member types    
*Name* - `int` is compatible with `int` 
*Extension* - derived classes are compatible with parent classes 


## Strong and Weak Typing 
A *strongly typed language* has a compiler that **checks for all types**, **conversions are explicit**, **types are constant in scope**.    
A *weakly typed language* is not strongly typed...    

### Type Binding 
*Type Binding* is what defines how a variable is given a type.   

*Explicit* - var **declaration** is separate from initialization   
*Implicit* - var type is determined by its name (@x = array)  

*Static* - type of var **cannot change** once it is declared   
*Dynamic* - type of var **can change** at any time


## Scope Checking 
Scope checking can be performed by using the symbol table.

### Static Scope 
A static scope language uses **program text** such as *code blocks (C++)* 

### Dynamic Scope 
A dynamic scope language uses **execution text** for scope. A function has access to the scope it was called from. 
